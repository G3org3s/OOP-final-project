package org.example;
import java.io.IOException;
import java.util.Comparator;
import java.util.HashMap;
import java.util.Map;
import java.time.LocalDate;
import java.time.temporal.ChronoUnit;

public abstract class Account implements Reportable {
    protected String accountId;
    protected Map<String, Security> holdings;

    public Account(String accountId) {
        this.accountId = accountId;
        this.holdings = new HashMap<>();
    }

    /**
     *
     * @param security
     */
    public void addSecurity(Security security) {
        if (holdings.containsKey(security.getTicker())) {
            double existingShareCount = holdings.get(security.getTicker()).getShareCount();
            double existingOriginalPrice = holdings.get(security.getTicker()).getOriginalPrice();

            security.setOriginalPrice((existingOriginalPrice * existingShareCount + security.getOriginalPrice() * security.getShareCount()) /
                    (existingOriginalPrice + security.getShareCount()));
            security.setShareCount((int) (existingShareCount + security.getShareCount()));
        }
        holdings.put(security.getTicker(), security);
    }

    /**
     * Calculates the total market value of all securities in this account.
     * @return the current market value of the portfolio.
     */
    public double getPortfolioMarketValue() {
        double totalValue = 0;
        for (Security security : holdings.values()) {
            totalValue += security.getMarketValue() * security.getShareCount();
        }
        return totalValue;
    }

    /**
     * Calculates the total absolute profit across all securities after a given number of years,
     * based on their individual growth assumptions.
     * @return the total profit (or loss if negative) generated by an account
     */
    public double getTotalProfit() {
        double originalValue = 0;
        for (Security security : holdings.values()) {
            originalValue += security.getOriginalPrice() * security.getShareCount();
        }
        return getPortfolioMarketValue() - originalValue;
    }



    /**
     * Writes a detailed report on the growth of the account (or loss)
     * @param outputFilePath file to output the report to
     * @throws IOException exception thrown
     */
    @Override
    public void writeReport(String outputFilePath) throws IOException {
        //todo
    }

    public String getAccountId() {
        return accountId;
    }

    public void setAccountId(String accountId) {
        this.accountId = accountId;
    }

    public Map<String, Security> getHoldings() {
        return holdings;
    }

    public void setHoldings(Map<String, Security> holdings) {
        this.holdings = holdings;
    }

    // Inner Comparator class for Account
    public static class AccountComparator implements Comparator<Account> {

        public AccountComparator() {
        }

        /**
         * Compares accounts based on the total profit earned
         * @param a1 the first object to be compared.
         * @param a2 the second object to be compared.
         * @return accounts in descending order
         */
        @Override
        public int compare(Account a1, Account a2) {
            return Double.compare(a2.getTotalProfit(), a1.getTotalProfit()); // descending order
        }
    }
}

